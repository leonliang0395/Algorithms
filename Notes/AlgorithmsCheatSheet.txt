Longest Palindromic Substring
O(N^2) Time O(1) Space:
  - For each letter, expand left + right till you find the biggest substring.

Trim Strings
    // trim from start (in place)
    static inline void ltrim(std::string &s) {
        s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int ch) {
            return !std::isspace(ch);
        }));
    }

    // trim from end (in place)
    static inline void rtrim(std::string &s) {
        s.erase(std::find_if(s.rbegin(), s.rend(), [](int ch) {
            return !std::isspace(ch);
        }).base(), s.end());
    }

Find the profit of the best trade in stock
    - Max Diff Technique
    - Keep track of the minimum_price so far, and for each element, check if the difference between minimum and this element
      is greater than the max profit so far.
    - Also update minimum_price if you find a lower price.
    
Find the best two profits in an array of stock prices
    - You essentially need to iterate through each element in the array.
        - For each iteration, you have to check the best prices in the subarray before the element, and after the element.
        - To do this, you need to have two functions to find the best price in subarr(0, i) and in subarr(i + 1, size).

Lowest Common Ancestor of a Binary Tree
- This assumes that nodes have a parent pointer
- Find the depth of the two nodes.
- Bring the node that's deeper, up to the same depth of the other node.
- Then move both up at the same time until they meet. That is the LCA.

Lowest Common Ancestor of a Binary Tree Without Parent Pointer 
- From the top, you check if the current node is the 1st or 2nd node.
- If it is, you return the current node.
- Then you make two recursive calls to left and right subtree. If they return a node, then the 1st or 2nd node is in 
  one of the subtrees. 
- Then you check if the left and right are not nullptrs, and if they are not, you found the LCA.
- If you've only found one of the subtrees, you return that node so it propagates up the stack. Eventually the
  earlier call to the function is expecting a node being found in their subtree.

Binary Tree Reconstruction from Inorder and Preorder
- The first element in the preorder traversal is the root.
- Find the index of the root in the inorder traversal.
- Then recursively pass the left side of the inorder, and pass the corresponding section of preorder to the left side.
- Also recursively pass the right side of the inorder, and pass the corresponding section of preorder to the right side.

Rotating a 2D Array
- Rotate layer by layer. Layers = size / 2.
- For each layer, you iterate through the number of elements on each side.
- For each element, you will take a copy of the top element, then move the left to top, bottom to left, right to bottom, top to right.

Ways to climb up to N steps
Bottom Up:
- Intervals are 1, 3, and 5.
- By going bottom up, you can figure out how many steps to get to step 1, 2, 3, etc.
- a[i + 1] = a[i + 1] + a[i], a[i + 3] = a[i + 3] + a[i]. etc.
- Perform this from 0 to a.size() - 1.
Top Down:
- a[i] = a[i - 1] + a[i - 3] + a[i - 5]
- So, iterate through 0 to a.size() - 1.
- In each iteration, you need the values of a[i - 1], a[i - 3], and a[i - 5].
- Initialize a[0] to 1.
